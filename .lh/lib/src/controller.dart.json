{
    "sourceFile": "lib/src/controller.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1657320813135,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1657320813135,
            "name": "Commit-0",
            "content": "part of native_video_view;\n\n/// Controller used to call the functions that\n/// controls the [VideoView] in Android and the [AVPlayer] in iOS.\nclass VideoViewController {\n  /// MethodChannel to call methods from the platform.\n  final MethodChannel _channel;\n\n  /// State of the [StatefulWidget].\n  final _NativeVideoViewState _videoViewState;\n\n  /// Current video file loaded in the player.\n  /// The [info] attribute is loaded when the player reaches\n  /// the prepared state.\n  VideoFile? _videoFile;\n\n  /// Returns the video file loaded in the player.\n  /// The [info] attribute is loaded when the player reaches\n  /// the prepared state.\n  VideoFile? get videoFile => _videoFile;\n\n  /// Timer to control the progression of the video being played.\n  Timer? _progressionController;\n\n  /// Constructor of the class.\n  VideoViewController._(\n    this._channel,\n    this._videoViewState,\n  ) {\n    _channel.setMethodCallHandler(_handleMethodCall);\n  }\n\n  /// Initialize the controller.\n  static Future<VideoViewController> init(\n    int id,\n    _NativeVideoViewState videoViewState,\n  ) async {\n    final MethodChannel channel = MethodChannel('native_video_view_$id');\n    return VideoViewController._(\n      channel,\n      videoViewState,\n    );\n  }\n\n  /// Disposes and stops some tasks from the controller.\n  void dispose() {\n    _stopProgressTimer();\n    _cleanTempFile();\n  }\n\n  /// Handle the calls from the listeners of state of the player.\n  Future<dynamic> _handleMethodCall(MethodCall call) async {\n    switch (call.method) {\n      case 'player#onCompletion':\n        _stopProgressTimer();\n        _videoViewState.notifyControlChanged(_MediaControl.stop);\n        _videoViewState.onCompletion(this);\n        break;\n      case 'player#onError':\n        _videoFile = null;\n        int what = call.arguments['what'] ?? -1;\n        int extra = call.arguments['extra'] ?? -1;\n        String? message = call.arguments['message'];\n        _videoViewState.onError(this, what, extra, message);\n        break;\n      case 'player#onPrepared':\n        VideoInfo videoInfo = VideoInfo._fromJson(call.arguments);\n        _videoFile =\n            _videoFile?._copyWith(changes: VideoFile._(info: videoInfo));\n        _videoViewState.onPrepared(this, videoInfo);\n        break;\n    }\n  }\n\n  /// Sets the video source from an asset file.\n  /// The [sourceType] parameter could be [VideoSourceType.asset],\n  /// [VideoSourceType.file] or [VideoSourceType.network]\n  Future<void> setVideoSource(\n    String source, {\n    VideoSourceType sourceType = VideoSourceType.file,\n    bool? requestAudioFocus,\n  }) async {\n    requestAudioFocus = requestAudioFocus ?? false;\n    if (sourceType == VideoSourceType.asset) {\n      File file = await _getAssetFile(source);\n      await _setVideosSource(file.path, sourceType, requestAudioFocus);\n    } else {\n      await _setVideosSource(source, sourceType, requestAudioFocus);\n    }\n  }\n\n  /// Load an asset file as a temporary file. File is removed when the\n  /// VideoView is disposed.\n  /// Returns the file path of the temporary file.\n  Future<File> _getAssetFile(String asset) async {\n    var tempFile = await _createTempFile();\n    ByteData data = await rootBundle.load(asset);\n    List<int> bytes =\n        data.buffer.asUint8List(data.offsetInBytes, data.lengthInBytes);\n    return tempFile.writeAsBytes(bytes);\n  }\n\n  /// Creates a new empty file. If the file exists, then is recreated to\n  /// ensure that the file is empty.\n  Future<File> _createTempFile() async {\n    var tempFile = await _getTempFile();\n    if (tempFile.existsSync()) tempFile.deleteSync();\n    tempFile.createSync();\n    return tempFile;\n  }\n\n  /// Remove the temporary file used for playing assets.\n  /// Returns true if the file was removed or file if not.\n  Future<bool> _cleanTempFile() async {\n    var tempFile = await _getTempFile();\n    if (tempFile.existsSync()) {\n      try {\n        tempFile.deleteSync();\n        return true;\n      } catch (ex) {\n        debugPrint(\"$ex\");\n      }\n    }\n    return false;\n  }\n\n  /// Returns the temp file for this instance of the widget.\n  Future<File> _getTempFile() async {\n    Directory directory = await getTemporaryDirectory();\n    return File(\"${directory.path}/temp_${_channel.name}.mp4\");\n  }\n\n  /// Sets the video source from a file in the device memory.\n  Future<void> _setVideosSource(String videoSource, VideoSourceType sourceType,\n      bool requestAudioFocus) async {\n    Map<String, dynamic> args = {\n      \"videoSource\": videoSource,\n      \"sourceType\": sourceType.toString(),\n      \"requestAudioFocus\": requestAudioFocus,\n    };\n    try {\n      await _channel.invokeMethod<void>(\"player#setVideoSource\", args);\n      _videoFile = VideoFile._(source: videoSource, sourceType: sourceType);\n    } catch (ex) {\n      debugPrint(\"$ex\");\n    }\n  }\n\n  /// Starts/resumes the playback of the video.\n  Future<bool> play() async {\n    try {\n      await _channel.invokeMethod(\"player#start\");\n      _startProgressTimer();\n      _videoViewState.notifyControlChanged(_MediaControl.play);\n      return true;\n    } catch (ex) {\n      debugPrint(\"$ex\");\n    }\n    return false;\n  }\n\n  /// Pauses the playback of the video. Use\n  /// [play] to resume the playback at any time.\n  Future<bool> pause() async {\n    try {\n      await _channel.invokeMethod(\"player#pause\");\n      _stopProgressTimer();\n      _videoViewState.notifyControlChanged(_MediaControl.pause);\n      return true;\n    } catch (ex) {\n      debugPrint(\"$ex\");\n    }\n    return false;\n  }\n\n  /// Stops the playback of the video.\n  Future<bool> stop() async {\n    try {\n      await _channel.invokeMethod(\"player#stop\");\n      _stopProgressTimer();\n      _resetProgressPosition();\n      _videoViewState.notifyControlChanged(_MediaControl.stop);\n      return true;\n    } catch (ex) {\n      debugPrint(\"$ex\");\n    }\n    return false;\n  }\n\n  /// Gets the current position of time in seconds.\n  /// Returns the current position of playback in milliseconds.\n  Future<int> currentPosition() async {\n    final result = await _channel.invokeMethod(\"player#currentPosition\");\n    return result['currentPosition'] ?? 0;\n  }\n\n  /// Moves the cursor of the playback to an specific time.\n  /// Must give the [position] of the specific millisecond of playback, if\n  /// the [position] is bigger than the duration of source the duration\n  /// of the video is used as position.\n  Future<bool> seekTo(int position) async {\n    try {\n      Map<String, dynamic> args = {\"position\": position};\n      await _channel.invokeMethod<void>(\"player#seekTo\", args);\n      return true;\n    } catch (ex) {\n      debugPrint(\"$ex\");\n    }\n    return false;\n  }\n\n  /// Gets the state of the player.\n  /// Returns true if the player is playing or false if is stopped or paused.\n  Future<bool?> isPlaying() async {\n    final result = await _channel.invokeMethod(\"player#isPlaying\");\n    return result['isPlaying'];\n  }\n\n  /// Changes the state of the volume between muted and not muted.\n  /// Returns true if the change was successful or false if an error happened.\n  Future<bool> toggleSound() async {\n    try {\n      await _channel.invokeMethod(\"player#toggleSound\");\n      _videoViewState.notifyControlChanged(_MediaControl.toggleSound);\n      return true;\n    } catch (ex) {\n      debugPrint(\"$ex\");\n    }\n    return false;\n  }\n\n  /// Sets the volume of the player.\n  Future<bool> setVolume(double volume) async {\n    try {\n      Map<String, dynamic> args = {\"volume\": volume};\n      await _channel.invokeMethod(\"player#setVolume\", args);\n      return true;\n    } catch (ex) {\n      debugPrint(\"$ex\");\n    }\n    return false;\n  }\n\n  /// Starts the timer that monitor the time progression of the playback.\n  void _startProgressTimer() {\n    _progressionController ??=\n        Timer.periodic(const Duration(milliseconds: 200), _onProgressChanged);\n  }\n\n  /// Stops the progression timer. If [resetCount] is true the elapsed\n  /// time is restarted.\n  void _stopProgressTimer() {\n    if (_progressionController != null) {\n      _progressionController!.cancel();\n      _progressionController = null;\n    }\n  }\n\n  /// Callback called by the timer when an event is called.\n  /// Updates the elapsed time counter and notifies the widget\n  /// state.\n  Future _onProgressChanged(Timer? timer) async {\n    if ((_progressionController?.isActive ?? false)) {\n      int position = await currentPosition();\n      int duration = videoFile?.info?.duration ?? 1000;\n      _videoViewState.onProgress(position, duration);\n    }\n  }\n\n  /// Resets the progress bar to the start.\n  void _resetProgressPosition() {\n    int duration = videoFile?.info?.duration ?? 1000;\n    _videoViewState.onProgress(0, duration);\n  }\n  \n   /// Sets the volume of the player.\n  Future<bool> changeAudio(int audio) async {\n    try {\n      Map<String, dynamic> args = {\"audio\": audio};\n      await _channel.invokeMethod(\"player#changeAudio\", args);\n      return true;\n    } catch (ex) {\n      debugPrint(\"$ex\");\n    }\n    return false;\n  }\n}\n"
        }
    ]
}